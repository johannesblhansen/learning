
GRPC uses protobuf for serialization, since it is much faster and smaller than serializing to text based message transfer, like REST usually use JSON or XML

Building proto files:

The proto files should go into src/main/proto (next to src/main/java)

```
syntax = "proto3";  
  
//Remember, proto is language neutral, so adding java specific properties like packages is added as options.  
option java_package = "dk.johannes.proto";  
  
message Person {  
    string name = 1;  
    int32 age = 2;  
}

```

The values string, int32 are called scalar types rather than primitive types like in java.

From the proto files, a maven plugin can use the protoc compiler to create autogenerated classes to use for server / client stubs.

To use the above to create a java class:
```
PersonOuterClass.Person.Builder builder = PersonOuterClass.Person.newBuilder();  
PersonOuterClass.Person person = builder.setName("someName").setAge(25).build();
```
The person object is immutable after being build.

*Note: The reason for the PersonOuterClass structure, is because of the proto file is named person. If the file is renamed, it will create a file with metadata with that name instead. Its a name clash thing.*

To serialize into protobuf binary format (to a file for example), just provide an outputstream:

```
person.writeTo(Files.newOutputStream(Path.of("this.thing")));
```

And to deserialize:
```
Person person = Person.parseFrom(Files.readAllBytes(Path.of("this.thing")));
```

Note: The serialization is one of places where protobuf (and therefore grpc) shines compared to REST. This is much faster than doing the same using a jackson object mapper. Also the serialized amount of bytes is a lot less using protobuf

Illustrated by the playground class ProtoVsJsonSeriaTestMain in here: [README](javacode/grpc/myfirstgrpc/README.md)
